\documentclass[10pt,a4paper,twocolumn,landscape,oneside]{article}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}                                                          
\usepackage[english,russian]{babel}
%\usepackage{expdlist}
%\usepackage{form}
\usepackage{amsmath}
\usepackage{amssymb}

\binoppenalty=10000
\relpenalty=10000
\sloppy

\providecommand{\reach}{\rightsquigarrow}
\renewcommand{\t}{\texttt}

\raggedbottom

\begin{document}

Фамилия \scriptline{5cm} Имя \scriptline{5cm}


\begin{enumerate}

\item
Выберите все истинные утверждения относительно элементов двоичной кучи $h[0\ldots n-1]$, 
в корне которой находится минимум (считайте, что $i$ и $j$ таковы, что все рассматриваемые
элементы существуют).

\nopagebreak
\begin{tabular}{lll}
\choice{$h[0] \le h[i]$}                &
\choice{$h[0] \le h[n - 1]$}                &
\choice{$h[i] \le h[n - 1]$}                \\ 
\choice{$h[i] \le h[i+1]$}              &
\choice{$h[i] \le h[2i+1]$}               & 
\choice{$h[i] \le h[2i+2]$}             \\
\choice{$h[i] \le h[(i - 1) \bdiv 2]$}        & 
\choice{$h[(i - 1) \bdiv 2] \le h[i]$}        &
\choice{$h[i] \ne h[j]$ при $i\ne j$}   \\
\end{tabular}

\item
Условие оптимальности для префиксов в задаче о кратчайшем пути в ациклическом
графе означает (выберите истинные утверждения):

\nopagebreak
\begin{tabular}{cp{12cm}}
\pchoice{Префикс $s \reach v$ оптимального пути $s \reach v \reach u$ всегда является оптимальным путем от~$s$ до~$v$}
\pchoice{Если префикс $s \reach v$ пути $s \reach v \reach u$ является оптимальным путем от $s$ до $v$, 
  то путь $s \reach v \reach u$ является оптимальным путем от  $s$ до $u$}                             
\end{tabular}
\begin{tabular}{cp{12cm}}
\pchoice{Если префикс $s \reach v$ пути $s \reach v \reach u$ является оптимальным путем от $s$ до $v$, 
  и фрагмент $v \reach u$ является оптимальным путем от $v$ до $u$, то путь $s \reach v \reach u$ 
  является оптимальным путем от  $s$ до $u$}
\end{tabular}

\item
Заполните таблицу параметров различных алгоритмов на графах. В графе SS отметьте, верно
ли, что алгоритм предназначен для нахождения путей от одной вершины до всех,
в графе W+~--- требуется ли для корректности работы алгоритма неторицательность
весов ребер, в графе T~--- оцените асимптотически время работы ($V$ --- число вершин в графе,
$E$ --- число ребер).

\nopagebreak
\begin{tabular}{|l|p{1.2cm}|p{1.2cm}|p{1.2cm}|}
\hline
\bf Алгоритм&\bf SS&\bf W+&\bf T\\
\hline
алгоритм Флойда&~&~&~\\
\hline
алгоритм Форда-Беллмана&~&~&~\\
\hline
алгоритм Дейкстры (простейший вариант)&~&~&~\\
\hline
алгоритм Дейкстры (с двоичной кучей)&~&~&~\\
\hline
\end{tabular}

\pagebreak
\item
После $k$ итераций внешнего цикла алгоритма Флойда элемент $a[i,j]$ матрицы расстояний содержит:

\nopagebreak
\begin{tabular}{cp{12cm}}
\pchoice{кратчайшую длину пути от вершины $i$ до вершины $j$}
\pchoice{кратчайшую длину пути, состоящего не более чем из $k$ ребер  от вершины $i$ до вершины~$j$}
\pchoice{кратчайшую длину пути, проходящего через вершины с номерами не более $k$, от вершины $i$ до вершины~$j$}
\end{tabular}


\item
После $k$ итераций внешнего цикла алгоритма Форда-Беллмана элемент $d[i]$ массива расстояний содержит:

\nopagebreak
\begin{tabular}{cp{12cm}}
\pchoice{кратчайшую длину пути до вершины $i$}
\pchoice{кратчайшую длину пути, состоящего не более чем из $k$ ребер, до вершины~$i$}
\pchoice{кратчайшую длину пути, проходящего через вершины с номерами не более $k$, до вершины~$i$}
\pchoice{число не превыщающее кратчайшую длину пути, состоящего не более чем из $k$ ребер, до вершины~$i$}
\end{tabular}


\item
За какое время можно построить дерево отрезков для заданного массива?

\nopagebreak
\choice{$O(n^2)$}
\choice{$O(n \log n)$}
\choice{$O(n)$}
\choice{$O(\log n)$}
\choice{$O(1)$}

\item
Выберите истинные утверждения про дерево Фенвика.
\nopagebreak
\begin{tabular}{cp{12cm}}
\pchoice{Дерево Фенвика можно построить за $O(n)$.}
\pchoice{Построение дерева Фенвика требует увеличения размера массива до степени двойки.}
\pchoice{Дерево Фенвика требует $O(1)$ дополнительной памяти.}
\pchoice{Дерево Фенвика можно построить для операции <<минимум>>.}
\pchoice{Дерево Фенвика можно построить для операции <<xor>>.}
\pchoice{Дерево Фенвика можно построить для операции <<умножение перестановок>>.}
\end{tabular}

\pagebreak

\item
Выберите истинные утверждения про декартово дерево.
\nopagebreak
\begin{tabular}{cp{12cm}}
\pchoice{Декартово дерево для пар чисел $(x_i, y_i)$ является двоичным деревом поиска по ключу $x_i$.}
\pchoice{В декартовом дереве для пар чисел $(x_i, y_i)$ соблюдается порядок кучи по ключу $y_i$.}
\pchoice{В декартовом дереве для пар чисел $(x_i, y_i)$ не может быть двух вершин с одинаковым ключом $y_i$.}
\pchoice{Декартово дерево требует $O(1)$ дополнительной памяти.}
%\pchoice{Декартово дерево позволяет решить задачу о $k$-й порядковой статистике на отрезке.}
\pchoice{Высота декартова дерева c $n$ вершинами~--- $O(\log n)$.}
\pchoice{Декартово дерево для $n$ пар чисел $(x_i, y_i)$ можно построить за $O(n)$.}
\pchoice{Декартово дерево для $n$ пар чисел $(i, y_i)$ можно построить за $O(n)$.}
\pchoice{Декартово дерево однозначно задается набором пар ключей $(x_i, y_i)$.}
\pchoice{Можно объединять два произвольных декартовых дерева за $O(\log n)$.}
\pchoice{Можно объединять два произвольных декартовых дерева за время, пропорциональное сумме их размеров.}
\pchoice{Можно делать операцию $\operatorname{split}$ по приоритетам за $O(\log n)$.}
\pchoice{В декартовом дереве по неявному ключу вместо ключей используются приоритеты.}
\end{tabular}

\item
Постройте дерево отрезков для операции минимум и набора чисел:  $\{21, 153, 7, 100, 9, 42, 256, 17, 194, 14\}$
\vspace{7cm}

\pagebreak
\item
Постройте дерево Фенвика для операции сложения и набора чисел:  $\{21, 153, 7, 100, 9, 42, 256, 17, 194, 14\}$
\vspace{7cm}

\item
Постройте skip-list для набора чисел: $\{21, 153, 7, 100, 9, 42, 256, 17, 194, 14\}$
\vspace{7cm}

\pagebreak
\item
За какое время возможно решение динамической задачи выбора минимума на отрезке (RMQ)? 
Выберите варианты, для которых вам известен алгоритм с временем предподготовки $P(n)$ и
временем обработки запроса на изменение элемента или получения минимума на отрезке $Q(n)$.
Для каждого из отмеченных вариантов укажите 
с помощью какой структуры данных эта оценка достигается и какое количество дополнительной памяти $M(n)$~--- необходимо.

\nopagebreak
\begin{tabular}{ll}
\choice{$P(n) = O(1)$, $Q(n) = O(n)$}                   &$M(n) = $\scriptline{5cm}  \\
\\
\choice{$P(n) = O(n)$, $Q(n) = O(\log n)$}              &$M(n) = $\scriptline{5cm}  \\
\\
\choice{$P(n) = O(n^2)$, $Q(n) = O(1)$}                 &$M(n) = $\scriptline{5cm}  \\    
\\
\choice{$P(n) = O(n \log n)$, $Q(n) = O(\log n)$}  &$M(n) = $\scriptline{5cm}  \\
\\
\choice{$P(n) = O(n \log n)$, $Q(n) = O(1)$}            &$M(n) = $\scriptline{5cm}  \\       
\\
\choice{$P(n) = O(n)$, $Q(n) = O(1)$}                   &$M(n) = $\scriptline{5cm}  \\
\\
\end{tabular}

\item
За какое время возможно решение статической задачи выбора минимума на отрезке (RMQ)? 
Выберите варианты, для которых вам известен алгоритм с временем предподготовки $P(n)$ и
временем обработки запроса получения минимума на отрезке $Q(n)$.
Для каждого из отмеченных вариантов укажите 
с помощью какой структуры данных эта оценка достигается и какое количество дополнительной памяти $M(n)$~--- необходимо.

\nopagebreak
\begin{tabular}{ll}
\\
\choice{$P(n) = O(1)$, $Q(n) = O(n)$}                   &$M(n) = $\scriptline{5cm}  \\
\\
\choice{$P(n) = O(n)$, $Q(n) = O(\log n)$}              &$M(n) = $\scriptline{5cm}  \\
\\     
\choice{$P(n) = O(n^2)$, $Q(n) = O(1)$}                 &$M(n) = $\scriptline{5cm}  \\    
\\
\choice{$P(n) = O(n \log n)$, $Q(n) = O(\log n)$}  &$M(n) = $\scriptline{5cm}  \\
\\
\choice{$P(n) = O(n \log n)$, $Q(n) = O(1)$}            &$M(n) = $\scriptline{5cm}  \\       
\\
\choice{$P(n) = O(n)$, $Q(n) = O(1)$}                   &$M(n) = $\scriptline{5cm}  \\
\\
\end{tabular}

\pagebreak
\item
За какое время возможно выполнение $m$ запросов о наименьшем общем предке (LCA) в дереве c $n$ вершинами в
режиме offline (Все запросы известны заранее)? 
Выберите варианты, для которых вам известен алгоритм с временем работы $P(n)$, укажите исползуемые структуры данных и алгоритм.

\nopagebreak
\begin{tabular}{ll}
\choice{$P(n) = O(nm)$}                 &\scriptline{7cm}  \\ 
\\
\choice{$P(n) = O(m \log n)$}   &\scriptline{7cm}  \\
\\
\choice{$P(n) = O(m \log * n)$}             &\scriptline{7cm}   \\       
\\
\choice{$P(n) = O(m + n)$}   &\scriptline{7cm}  \\
\\
\choice{$P(n) = O(1)$}                      &\scriptline{7cm}   \\
\\
\end{tabular}

\item
За какое время возможно решение задачи нахождения наименьшего общего предка в дереве в
режиме online (LCA)? 
Выберите варианты, для которых вам известен алгоритм с временем предподготовки $P(n)$ и
временем обработки запроса $Q(n)$. Для каждого из отмеченных вариантов укажите 
необходимое количество дополнительной памяти $M(n)$ для известного вам метода.

\nopagebreak
\begin{tabular}{ll}
\choice{$P(n) = O(1)$, $Q(n) = O(n)$}                   &$M(n) = $\scriptline{5cm}  \\
\\
\choice{$P(n) = O(n)$, $Q(n) = O(\log n)$}              &$M(n) = $\scriptline{5cm}  \\     
\\
\choice{$P(n) = O(n^2)$, $Q(n) = O(1)$}                 &$M(n) = $\scriptline{5cm}  \\    
\\
\choice{$P(n) = O(n \log n)$, $Q(n) = O(\log n)$}   &$M(n) = $\scriptline{5cm}  \\
\\
\choice{$P(n) = O(n \log n)$, $Q(n) = O(1)$}            &$M(n) = $\scriptline{5cm}  \\       
\\
\choice{$P(n) = O(n)$, $Q(n) = O(1)$}                   &$M(n) = $\scriptline{5cm}  \\
\end{tabular}

\pagebreak

\item
За какое время возможно реализации структуры данных для системы непересекающихся
множеств? Выберите варианты, для которых вам известен алгоритм с указанным
временем работы для $m$ операций \texttt{get} и $n$ операций \texttt{union}
($m \ge n$), и укажите используемые структуры данных.

\nopagebreak
\begin{tabular}{llll}
\\
\choice{$O(m + n^2)$}           &              
\\
\\
\choice{$O(m + n \log n)$}      &          
\\
\\
\choice{$O(m \log n)$}          &  
\\
\\
\choice{$O(m \log^* n)$}        &    
\\
\\
\choice{$O(m + n \log^* n)$}    &          
\\
\\
\choice{$O(m + n)$}             \\ 
\\
\end{tabular}

\item 
Выберите истинные утверждения.

\begin{tabular}{cp{12cm}}
\pchoice{Если объекты равны, то хеши могут быть равны.}
\pchoice{Если объекты равны, то хеши могут быть не равны.}
\pchoice{Если хеши равны, то объекты могут быть равны.}
\pchoice{Если хеши равны, то объекты могут быть не равны.}
\pchoice{Если объекты не равны, то хеши всегда не равны.}
\pchoice{Если хеши не равны, то объекты всегда не равны.}
\pchoice{$h(x)=1$ является корректной хеш-функцией.}
\pchoice{$h(x)=\operatorname{rand}\{0, 1\}$ является корректной хеш-функцией.}
\end{tabular}

\item
Для хеширования строки $s$, состоящей из маленьких латинских букв, была 
применена формула $\sum\limits_{i=1}^{n}(s_i - \texttt{'a'}) p^{n-i}$. 
Приведите пример двух различных строк, имеющих одинаковый хеш.


\item
Выберите истинные утверждения.

\nopagebreak
\begin{tabular}{cp{12cm}}
\pchoice{Алгоритм Ахо-Корасик позволяет найти количество вхождений строк $S_i$ в текст $T$ за время $O(\sum |S_i|+|T|)$.}
\pchoice{Алгоритм Ахо-Корасик позволяет найти все вхождения строк $S_i$ в текст $T$ за время $O(\sum |S_i|+|T|)$.}
\pchoice{Алгоритм Ахо-Корасик позволяет найти наибольшую общую подстроку двух строк с длинами $n$ и $m$ за $O(n+m)$.}
\pchoice{Алгоритм Ахо-Корасик позволяет найти наибольший префикс строки $S$ входящий в строку $T$ за $O(|S|+|T|)$.}
\pchoice{Глубина вершины в которую указывает суффиксная ссылка, построенная алгоритмом Ахо-Корасик для одной строки, совпадают с префикс функцией для этой строки.}
\pchoice{Суффиксные ссылки, построенные алгоритмом Ахо-Корасик для одной строки, совпадают с $Z$-функцией для этой строки.}
\end{tabular}

\item
Пусть $Z[i]$ - $Z$-функция, а $\pi$ - префикс функция.
Выберите истинные утверждения.

\nopagebreak
\begin{tabular}{cp{12cm}}
\pchoice{Для строки $S$ и любого $i < j$ верно, что $Z[i] \le Z[j]$.}
\pchoice{Для строки $S$ и любого $i < j$ верно, что $Z[i] \ge Z[j]$.}
\pchoice{Для строки $S$ и любого $i < j$ верно, что $\pi[i] \le \pi[j]$.}
\pchoice{Для строки $S$ и любого $i < j$ верно, что $\pi[i] \ge \pi[j]$.}
\pchoice{Для строки $S$ и любого $i$ верно, что $\pi[i] \le Z[i]$.}
\pchoice{Для строки $S$ и любого $i$ верно, что $\pi[i] \ge Z[i]$.}
\pchoice{Для строки $S$ и любого $i$ верно, что $Z[i] \le i$.}
\pchoice{Для строки $S$ и любого $i$ верно, что $Z[i] \ge i$.}
\pchoice{Для строки $S$ и любого $i$ верно, что $\pi[i] \le i$.}
\pchoice{Для строки $S$ и любого $i$ верно, что $\pi[i] \ge i$.}
\pchoice{Для строки $S$ и любого $i$ верно, что $Z[i] \le Z[Z[i]]$.}
\pchoice{Для строки $S$ и любого $i$ верно, что $Z[i] \ge Z[Z[i]]$.}
\pchoice{Для строки $S$ и любого $i$ верно, что $Z[i] \le Z[\pi[i]]$.}
\pchoice{Для строки $S$ и любого $i$ верно, что $Z[i] \ge Z[\pi[i]]$.}
\pchoice{Для строки $S$ и любого $i$ верно, что $\pi[i] \le \pi[\pi[i]]$.}
\pchoice{Для строки $S$ и любого $i$ верно, что $\pi[i] \ge \pi[\pi[i]]$.}
\pchoice{$Z$-функция позволяет найти наибольшую общую подстроку двух строк $S$ и $T$ за $O(|S|+|T|)$.}
\pchoice{$Z$-функция позволяет найти все вхождения строки $S$ в текст $T$ за $O(|S|+|T|)$.}
\pchoice{$Z$-функцию для строки $S$ можно вычислить за $O(|S|)$.}
\end{tabular}



\item
Подстроку длины $m$ можно найти в строке длины $n$ за время:

\nopagebreak
\begin{tabular}{llllll}
\choice{$O(m^2n)$}\quad&
\choice{$O(mn^2)$}\quad&
\choice{$O(nn)$}\quad&
\choice{$O(m+n)$}\quad&
\choice{$O(n/m)$}
\end{tabular}

\item
Выберите верные утверждения:

\nopagebreak
\begin{tabular}{cp{12cm}}
\pchoice{Суффиксный массив (СМ) содержит номера суффиксов строки в порядке увеличения длины.}
\pchoice{СМ содержит номера суффиксов строки в лексикографическом порядке.}
\pchoice{СМ содержит номера префиксов строки в порядке увеличения длины.}
\pchoice{СМ содержит номера префиксов строки в лексикографическом порядке.}
\pchoice{СМ строки длины $n$ можно построить за время $O(n^2)$.}
\pchoice{СМ строки длины $n$ можно построить за время $O(n\log n)$.}
\pchoice{СМ строки длины $n$ можно построить за время $O(n)$.}
\end{tabular}
\begin{tabular}{cp{12cm}}
\pchoice{СМ строки длины $n$ позволяет искать в ней подстроку длины $m$ за $O(nm)$.}
\pchoice{СМ строки длины $n$ позволяет искать в ней подстроку длины $m$ за $O(n\log m)$.}
\pchoice{СМ строки длины $n$ позволяет искать в ней подстроку длины $m$ за $O(m\log n)$.}
\pchoice{СМ строки длины $n$ позволяет искать в ней подстроку длины $m$ за $O(m + \log n)$.}
\pchoice{СМ строки длины $n$ позволяет искать в ней подстроку длины $m$ за $O(n)$.}
\pchoice{СМ строки длины $n$ позволяет искать в ней подстроку длины $m$ за $O(m)$.}
\end{tabular}

\item
Выберите верные утверждения:

\nopagebreak
\begin{tabular}{cp{12cm}}
\pchoice{Суффиксный автомат (СА) допускает все суффиксы заданной строки.}
\pchoice{СА допускает все префиксы заданной строки.}
\pchoice{СА допускает все подстроки заданной строки.}
\pchoice{СА для строки длины $n$ содержит $O(n)$ состояний.}
\pchoice{СА для строки длины $n$ содержит $O(n)$ переходов.}
\pchoice{СА для строки длины $n$ можно построить за время $O(n^2)$.}
\pchoice{СА для строки длины $n$ можно построить за время $O(n\log n)$.}
\pchoice{СА для строки длины $n$ можно построить за время $O(n)$.}
\pchoice{СА для строки длины $n$ позволяет искать в ней подстроку длины $m$ за $O(nm)$.}
\pchoice{СА для строки длины $n$ позволяет искать в ней подстроку длины $m$ за $O(n\log m)$.}
\end{tabular}
\begin{tabular}{cp{12.2cm}}
\pchoice{СА для строки длины $n$ позволяет искать в ней подстроку длины $m$ за $O(m\log n)$.}
\pchoice{СА для строки длины $n$ позволяет искать в ней подстроку длины $m$ за $O(m + \log n)$.}
\pchoice{СА для строки длины $n$ позволяет искать в ней подстроку длины $m$ за $O(n)$.}
\pchoice{СА для строки длины $n$ позволяет искать в ней подстроку длины $m$ за $O(m)$.}
\end{tabular}

\item
Выберите верные утверждения:

\nopagebreak
\begin{tabular}{cp{12cm}}
\pchoice{Суффиксное дерево содержит все суффиксы заданной строки.}
\pchoice{Суффиксное дерево содержит все префиксы заданной строки.}
\pchoice{Суффиксное дерево содержит все подстроки заданной строки.}
\pchoice{Сжатое суффиксное дерево строки длины $n$ содержит $O(n)$ вершин.}
\pchoice{Сжатое суффиксное дерево строки длины $n$ содержит $O(n)$ ребер.}
\pchoice{Сумма длин пометок ребер суффиксного дерева строки длины $n$ есть $O(n)$.}
\pchoice{Сумма длин пометок ребер суффиксного дерева строки длины $n$ есть $O(n^2)$.}
\pchoice{Сжатое суффиксное дерево строки длины $n$ можно построить за время $O(n^2)$.}
\pchoice{Сжатое суффиксное дерево строки длины $n$ можно построить за время $O(n\log n)$.}
\pchoice{Сжатое суффиксное дерево строки длины $n$ можно построить за время $O(n)$.}
\pchoice{Сжатое суффиксное дерево строки длины $n$ позволяет искать в ней подстроку длины $m$ за время $O(nm)$.}
\pchoice{Сжатое суффиксное дерево строки длины $n$ позволяет искать в ней подстроку длины $m$ за время $O(n\log m)$.}
\pchoice{Сжатое суффиксное дерево строки длины $n$ позволяет искать в ней подстроку длины $m$ за время $O(m\log n)$.}
\pchoice{Сжатое суффиксное дерево строки длины $n$ позволяет искать в ней подстроку длины $m$ за время $O(m + \log n)$.}
\pchoice{Сжатое суффиксное дерево строки длины $n$ позволяет искать в ней подстроку длины $m$ за время $O(n)$.}
\pchoice{Сжатое суффиксное дерево строки длины $n$ позволяет искать в ней подстроку длины $m$ за время $O(m)$.}
\end{tabular}

\item
Постройте суффиксный массив для строки: <<ababaababba>>.
\pagebreak
\item
Постройте суффиксный автомат и дерево правых контекстов для строки: <<ababaababba>>.
\pagebreak
\item
Постройте сжатое суффиксное дерево для строки: <<ababaababba>>.
\pagebreak

\item
Укажите, для каких из приведенных задач вы знаете алгоритм решения за полиномиальное время.
Укажите его асимптотику.

\nopagebreak
\begin{tabular}{|p{8cm}|l|}
\hline
\bf Задача&\bf Время работы алгоритма\\
\hline
Поиск максимального паросочетания в двудольном графе&\\
\hline
Поиск максимального паросочетания в произвольном графе&\\
\hline
Поиск паросочетания минимального веса в двудольном графе (задача о назначениях)&\\
\hline
Поиск паросочетания минимального веса в произвольном графе&\\
\hline
Поиск минимального вершинного покрытия в двудольном графе&\\
\hline
Поиск минимального вершинного покрытия в произвольном графе&\\
\hline
Поиск максимального потока&\\&\\
\hline
Поиск потока минимальной стоимости&\\&\\
\hline
\end{tabular}

\item
Выберите истинные утверждения.

\nopagebreak
\begin{tabular}{cp{12cm}}
\pchoice{Минимальный поток из $s$ в $t$ в сети $G$ равен максимальному $s$-$t$ разрезу.}
\pchoice{В сети $G$ существует единственный максимальный поток
тогда и только тогда, когда в ней существует единственный минимальный разрез.}
\pchoice{Алгоритм Форда-Фалкерсона работает за полиномиальное время от количества ребер.}
\pchoice{Максимальный поток в сети с целыми пропускными способностями всегда целый.}
\pchoice{Любой поток можно разложить в сумму потоков вдоль путей из истока в сток.}
\pchoice{Любой поток из $s$ в $t$ в сети $G$ не больше любого $s$-$t$ разреза в сети $G$.}
\pchoice{Поток является максимальным тогда и только тогда когда в остаточной сети нет циклов.}
\pchoice{Поток имеет величину 0 тогда и только тогда, когда поток по каждому ребру равен 0.}
\pchoice{Поток по ребру равен потоку по обратному ребру.}
\pchoice{Поток $f$ является максимальным, если на любом пути из $s$ в $t$ в $G$ найдется насыщенное ребро.}
\pchoice{Поток $f$ является максимальным, если на любом пути из $s$ в $t$ в $G_f$ найдется насыщенное ребро.}
\end{tabular}


\item
Выберите верные утверждения:

\nopagebreak
\begin{tabular}{cp{12cm}}
\pchoice{При анализе игры на ациклическом графе используется поиск в глубину.}
\pchoice{При анализе игры на ациклическом графе используется поиск в ширину.}
\pchoice{При анализе игры на графе с циклами используется поиск в глубину.}
\pchoice{При анализе игры на графе с циклами используется поиск в ширину.}                
\pchoice{Все позиции в игре на ациклическом графе являются либо выигрышными, либо проигрышными.}
\pchoice{Все позиции в игре на графе с циклами являются либо выигрышными, либо проигрышными.}
\pchoice{Если позиция в игре на графе является ничейной то она лежит на цикле.}
\pchoice{Если позиция в игре на графе лежит на цикле, то она является ничейной.}
\pchoice{Позиции в игре на графе является ничейной тогда и только тогда, когда
    она лежит на цикле.}
\end{tabular}

\item
Выберите верные утверждения:

\nopagebreak
\begin{tabular}{cp{12cm}}
\pchoice{Сумма игр на графах, содержащих $m$ и $n$ позиций, соответственно, является игрой,
    содержащей $m+n$ позиций.}
\pchoice{Сумма игр на графах, содержащих $m$ и $n$ позиций, соответственно, является игрой,
    содержащей $mn$ позиций.}
\pchoice{Две игры на графе являются эквивалентными по Гранди, если они имеют одинаковый исход.}
\pchoice{Две игры на графе являются эквивалентными по Гранди, если они имеют одинаковый исход
    при суммировании с любой игрой.}
\pchoice{Две игры на графе являются эквивалентными по Гранди, если они имеют одинаковый исход
    при суммировании с ничейной игрой.}
\pchoice{Любая игра на ациклическом графе эквивалентна игре ним.}
\pchoice{Любая игра на графе эквивалентна игре ним.}
\pchoice{Любая игра на графе, которая не является ничейной, эквивалентна игре ним.}
\end{tabular}
\begin{tabular}{cp{12cm}}
\pchoice{Функция Гранди позиции $u$ в игре на графе равна сумме функций Гранди позиций, в которые из
    нее возможен ход.}
\pchoice{Функция Гранди позиции $u$ в игре на графе равна минимуму из функций Гранди позиций, в которые из
    нее возможен ход.}
\pchoice{Функция Гранди позиции $u$ в игре на графе равна максимуму из функций Гранди позиций, в которые из
    нее возможен ход.}
\pchoice{Функция Гранди позиции $u$ в игре на графе равна максимуму из функций Гранди позиций, в которые из
    нее возможен ход, плюс один.}
\pchoice{Функция Гранди позиции $u$ в игре на графе равна минимальному целому неотрицательному числу, не встречающемуся среди
    функций Гранди позиций, в которые из нее есть ход.}
\end{tabular}

\pagebreak

\item
При суммировании игр с функциями Гранди $a$ и $b$ получается игра с функцией Гранди:

\begin{tabular}{llllll}
\choice{$a+b$}\quad&
\choice{$ab$}\quad&
\choice{$a\oplus b$}\quad&
\choice{$\min(a, b)$}\quad&
\choice{$\max(a, b)$}\quad&
\choice{$\max(a, b)+1$}
\end{tabular}

\item
Приведите пример, когда алгоритм Мелькмана не находит корректную выпуклую
оболочку.
\vspace{7cm}

\item
Выберите истинные утверждения:

\nopagebreak
\begin{tabular}{cp{12cm}}
\pchoice{Можно проверить непустоту пересечения многоугольника с прямой за $O(\log n)$.}
\pchoice{Можно проверить непустоту пересечения выпуклого многоугольника с прямой за $O(\log n)$.}
\pchoice{Можно проверить непустоту пересечения многоугольника с прямой и, если оно непусто, 
            найти точку пересечения за $O(\log n)$.}
\pchoice{Можно проверить непустоту пересечения выпуклого многоугольника с прямой и, если 
            оно непусто, найти точку пересечения за $O(\log n)$.}
\pchoice{Можно проверить непустоту пересечения многоугольника с прямой за $O(n)$.}
\pchoice{Можно проверить непустоту пересечения выпуклого многоугольника с прямой за $O(n)$.}
\pchoice{Можно проверить непустоту пересечения многоугольника с прямой и, если оно непусто, 
            найти точку пересечения за $O(n)$.}
\pchoice{Можно проверить непустоту пересечения выпуклого многоугольника с прямой и, если 
            оно непусто, найти точку пересечения за $O(n)$.}
\pchoice{Можно проверить непустоту пересечения $n$ полуплоскостей за $O(n^3)$.}
\pchoice{Можно проверить непустоту пересечения $n$ полуплоскостей за $O(n^2 \log n)$.}
\pchoice{Можно проверить непустоту пересечения $n$ полуплоскостей за $O(n^2)$.}
\pchoice{Можно проверить непустоту пересечения $n$ полуплоскостей за $O(n \log n)$.}
\pchoice{Можно проверить непустоту пересечения $n$ полуплоскостей за $O(n)$.}
\end{tabular}
\end{enumerate}

\end{document}
